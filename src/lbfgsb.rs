// [[file:../lbfgsb.note::*imports][imports:1]]

#[allow(clippy::all)]
mod bindings { include!(concat!(env!("OUT_DIR"), "/bindings_0.rs")); }
use bindings::{integer, logical, NEW_X, START};

extern "C" {
    #[allow(clashing_extern_declarations)]
    pub fn setulb(
        n: *const integer,
        m: *const integer,
        x: *mut f64,
        l: *const f64,
        u: *const f64,
        nbd: *const integer,
        f: *mut f64,
        g: *mut f64,
        factr: *const f64,
        pgtol: *const f64,
        wa: *mut f64,
        iwa: *mut integer,
        task: *mut integer,
        iprint: *const integer,
        csave: *mut integer,
        lsave: *mut logical,
        isave: *mut integer,
        dsave: *mut f64,
    ) -> ::std::os::raw::c_int;
}

use anyhow::Result;

use crate::shared::{is_fg, LbfgsbParameter, LbfgsbProblem};
// imports:1 ends here

impl<'a, E> LbfgsbState<'a, E>
where
    E: FnMut(&[f64], &mut [f64]) -> Result<f64>,
{
    pub(crate) fn minimize(&mut self) -> Result<()> {
        let f = &mut self.problem.f;
        let x = &mut self.problem.x;
        let g = &mut self.problem.g;
        let l = &self.problem.l;
        let u = &self.problem.u;
        let nbd = &self.problem.nbd;

        let param = &self.param;
        let n = x.len();
        let m = param.m;
        loop {
            unsafe {
                #[allow(clashing_extern_declarations)]
                setulb(
                    &(n as i64),             //x
                    &(m as i64),             //x
                    x.as_mut_ptr(),          //x
                    l.as_ptr(),              //x
                    u.as_ptr(),              //x
                    nbd.as_ptr(),            //x
                    f,                       //x
                    g.as_mut_ptr(),          //x
                    &param.factr,            //x
                    &param.pgtol,            //x
                    self.wa.as_mut_ptr(),    //x
                    self.iwa.as_mut_ptr(),   //x
                    &mut self.task,          //x
                    &param.iprint,           //x
                    self.csave.as_mut_ptr(), //x
                    self.lsave.as_mut_ptr(), //x
                    self.isave.as_mut_ptr(), //x
                    self.dsave.as_mut_ptr(), //x
                );
            }
            if is_fg(self.task) {
                // the minimization routine has returned to request the
                // function f and gradient g values at the current x.
                // Compute function value f for the sample problem.
                *f = (self.problem.eval_fn)(x, g)?;
            // go back to the minimization routine.
            } else if self.task == NEW_X as i64 {
                // the minimization routine has returned with a new iterate, and we have
                // opted to continue the iteration.
            } else {
                // If task is neither FG nor NEW_X we terminate execution.
                break;
            }
        }

        Ok(())
    }
}
// 9e5b03b1 ends here

// [[file:../lbfgsb.note::*pub][pub:1]]
/// Minimize a scalar function of one or more variables using the L-BFGS-B
/// algorithm.
///
/// # Parameters
///
/// - bounds: a slice of tuple setting lower and upper bounds.
/// - eval_fn: a closure evaluating f(x) and g(x). Returning Err value will cancel minimization.
///
/// # Return
///
/// - Returns final state containing x, f(x), g(x).
pub fn lbfgsb<E>(problem: &mut LbfgsbProblem<E>, params: LbfgsbParameter) -> Result<()>
where
    E: FnMut(&[f64], &mut [f64]) -> Result<f64>,
{
    let mut state = LbfgsbState::new(problem, params);
    state.minimize()
    // Ok(state.x().to_vec())
}
// pub:1 ends here




// [[file:../lbfgsb.note::9e5b03b1][9e5b03b1]]
pub struct LbfgsbState<'a, E>
where
    E: FnMut(&[f64], &mut [f64]) -> Result<f64>,
{
    problem: &'a mut LbfgsbProblem<E>,

    param: LbfgsbParameter,

    /// wa is a double precision working array of length:
    ///   (2mmax + 5)nmax + 12mmax^2 + 12mmax.
    wa: Vec<f64>,

    // iwa is an integer working array of length 3nmax.
    iwa: Vec<i64>,

    // csave is a working string of characters of length 60.
    // static char csave[60];
    csave: [i64; 60],
    // static double dsave[29];
    //  dsave is a double precision working array of dimension 29.
    // On exit with 'task' = NEW_X, the following information is
    //                                                       available:
    //   dsave(1) = current 'theta' in the BFGS matrix;
    //   dsave(2) = f(x) in the previous iteration;
    //   dsave(3) = factr*epsmch;
    //   dsave(4) = 2-norm of the line search direction vector;
    //   dsave(5) = the machine precision epsmch generated by the code;
    //   dsave(7) = the accumulated time spent on searching for
    //                                                   Cauchy points;
    //   dsave(8) = the accumulated time spent on
    //                                           subspace minimization;
    //   dsave(9) = the accumulated time spent on line search;
    //   dsave(11) = the slope of the line search function at
    //                            the current point of line search;
    //   dsave(12) = the maximum relative step length imposed in
    //                                                     line search;
    //   dsave(13) = the infinity norm of the projected gradient;
    //   dsave(14) = the relative step length in the line search;
    //   dsave(15) = the slope of the line search function at
    //                           the starting point of the line search;
    //   dsave(16) = the square of the 2-norm of the line search
    //                                                direction vector.
    dsave: [f64; 29],

    // isave is an integer working array of dimension 44.
    //   On exit with 'task' = NEW_X, the following information is
    //                                                         available:
    //     isave(22) = the total number of intervals explored in the
    //                     search of Cauchy points;
    //     isave(26) = the total number of skipped BFGS updates before
    //                     the current iteration;
    //     isave(30) = the number of current iteration;
    //     isave(31) = the total number of BFGS updates prior the current
    //                     iteration;
    //     isave(33) = the number of intervals explored in the search of
    //                     Cauchy point in the current iteration;
    //     isave(34) = the total number of function and gradient
    //                     evaluations;
    //     isave(36) = the number of function value or gradient
    //                              evaluations in the current iteration;
    //     if isave(37) = 0  then the subspace argmin is within the box;
    //     if isave(37) = 1  then the subspace argmin is beyond the box;
    //     isave(38) = the number of free variables in the current
    //                     iteration;
    //     isave(39) = the number of active constraints in the current
    //                     iteration;
    //     n + 1 - isave(40) = the number of variables leaving the set of
    //                       active constraints in the current iteration;
    //     isave(41) = the number of variables entering the set of active
    //                     constraints in the current iteration.
    isave: [i64; 44],
    // static logical lsave[4];
    // lsave is a logical working array of dimension 4. On exit with 'task' =
    // NEW_X, the following information is available:
    //
    //   If lsave(1) = .true. then the initial X has been replaced by its
    //   projection in the feasible set;
    //
    //   If lsave(2) = .true.  then  the problem is constrained;
    //
    //   If lsave(3) = .true. then each variable has upper and lower bounds;
    lsave: [i64; 4],

    // Note in original fortran version:
    //
    // task is a working string of characters of length 60 indicating
    // the current job when entering and leaving this subroutine.
    //
    // Note in L-BFGS-B-C
    //
    // Modified L-BFGS-B to use integers instead of strings, for testing the
    // "task"
    task: i64,
}


impl<'a, E> LbfgsbState<'a, E>
where
    E: FnMut(&[f64], &mut [f64]) -> Result<f64>,
{
  fn new(problem: &'a mut LbfgsbProblem<E>, param: LbfgsbParameter) -> Self {
    let n = problem.x.len();
    let m = param.m;
    
    // wa is a double precision working array of length
    //   (2mmax + 5)nmax + 12mmax^2 + 12mmax.
    let wa = vec![0.0; 2 * m * n + 5 * n + 11 * m * m + 8 * m];

    // iwa is an integer working array of length 3nmax.
    let iwa = vec![0; 3 * n];

    Self {
      csave: [0; 60],
      dsave: [0.0; 29],
      isave: [0; 44],
      lsave: [0; 4],
      task: START.into(),
      problem,
      param,
      wa,
      iwa,
    }
  }

  // /// Final function value f(x)
  // pub fn fx(&self) -> f64 {
  //   self.problem.f
  // }

  // /// Final evaluated gradient g(x)
  // pub fn gx(&self) -> &[f64] {
  //   &self.problem.g
  // }

  // /// Final optimized `x`
  // pub fn x(&self) -> &[f64] {
  //   &self.problem.x
  // }
  
}